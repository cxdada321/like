package edu.hust.like;

import java.util.HashMap;

/**
 * 分割数组
 */
public class DivideArray {
    static int min = Integer.MAX_VALUE;

    //用来存储0-n范围内的所有质数
    static int[] prime = new int[1000001];
    static int max = Integer.MAX_VALUE;
    //素数筛
    static {
        int n = 1000000;
        //外层遍历
        for (int i = 2; i * i <= n; i++) {
            //表示不是质数跳过
            if (prime[i] > 0) {
                continue;
            }
            //内层循环，用质数去找合数的最小质数
            for (int j = i * i; j <= n; j += i) {
                prime[j] = i;
            }
        }
    }

    /**
     * 给定一个整数数组 nums ，小李想将 nums 切割成若干个非空子数组，使得每个子数组最左边的数和最右边的数的最大公约数大于 1 。
     * 为了减少他的工作量，请求出最少可以切成多少个子数组。
     *
     * @param args
     */
    public static void main(String[] args) {
        int[] nums = {782581,227,113147,13451,288053,684113,413579,917629,454021,827633,673787,514127,432001,507961,790051,164617,139759,315881,160681,235231,106627,135977,483811,570839,758699,549011,389227,21961,524347,24763,882247,932101,717559,124853,967919,968111,966439,967229,967739,968213,967171,966509,967397,967481,968111,967297,968311,967753,966677,968573,966527,966653,967319,967663,967931,968021,967961,968423,966727,967937,967699,966883,968017,968311,967781,966617,967937,967763,967459,966971,968567,968501,966991,966613,968557,966863,966619,966863,966727,967567,967061,966913,966631,968021,968003,968431,968291,969667,970667,971723,969011,972113,972373,969929,971491,970027,973031,982973,980491,985657};
        //递归的做法时间复杂度比较高，并且存在一定问题
//        int res = splitArray(nums);
        //采用DP结合质数筛解决
        int res = splitArray1(nums);
        System.out.println(res);
    }

    //利用素数筛，将0-n范围内的素数都筛选出来，并且把合数的最小质因数保存到合数数组里
    //这里注意技巧，因为是要找到0-n范围内的所有素数，因此外层遍历的时候结束条件是i*i<=n，这样可以减少一半的遍历次数，为什么呢
    //因为比如一个数n，如果它是合数，那么它一定有一个小于等于根号n的质因数，所以只要遍历到根号n就可以了，不可能有大于根号n的质因数
    //对于标记了的合数即跳过，这样进入内层循环的时候能保证只有质数
    //内层遍历的时候如何找出合数的最小质因数呢，采用的是初始值是j=i*i，每次以i的步长增长，因为i是当前能得到这个合数的最小质因数了
    //如果这个合数存在更小的质因数，前面遍历更小的质因数的时候就遍历过了，所以这里从i*i开始遍历，用i的步长是保证后面的合数都是i的倍数


    //这样的设计很巧妙，这样就能找到0-n范围内所有的质数和合数的最小质因数

    //动态规划 f[i] 代表这个数组新增一个质数 i 后的最少分组数
    //用一个dp记录当前位置的最小分组数，这样最终整个数组的最小分组数就是dp[n]，
    //用一个map记录每个质因数 j 最后一次出现之前，切割的最小值，即不算上质因数 j 的最小分组数，这样方便用来合并
    //即遍历一个新的数的时候，如果这个数的质因数在前面有出现过，那么这个数就可以和前面的数合并，这样就可以减少分组数
    //这里新出现的质因数是否要和前面出现过的质因数合并，取决于当前dp合并后是否比之前的dp小，如果小就合并，不然就不合并
    //为什么这样呢，因为之前出现的质因数可能和前面已经合并过了，如果前面合并后的结果加上当前数单独做一组得到的切割数更小，就不需要把前面合并的数拿来和这个数合并

    //map 存储的是到目前为止，对于每个质因子，能达到的最小的 dp 值。 它不是记录哪个 特定 的数字使用了这个因子，而是记录了在当前索引之前，允许使用该因子的最佳分割点
    //所以一个dp[i]值取于两种情况：一，当前数不能和前面的数合并，就是到上个数为止最小切割数+1
    //二：当前数可以和前面的数合并，要不要合并也是两种情况；一种是合并，那就应该是选择合并的质因数j,map.get(j)+1，map.get(j)表示不含质因数j的最小切割数
    //另一种是不合并，那就是当前数单独做一组，即dp[i] = dp[i-1]+1
    private static int splitArray1(int[] nums) {
        int n = nums.length;
        //用来保存质因数最后一次出现之前的最小切割数
        HashMap<Integer, Integer> map = new HashMap<>();
        int[] dp = new int[n + 1];
        for (int i = 0; i < n; i++) {
            //取出数组中的值用来分解质因数
            int num = nums[i];
            while (num > 1) {
                //取出质因数，如果是质数的话那就是其本身
                int j = prime[num] > 0 ? prime[num] : num;
                //用于继续分解求出下一个质因数
                num /= j;
                //给dp初始化，即每多一个数默认是新开一组
                dp[i + 1] = dp[i] + 1;
                //如果新加的数和前面的数存在相同的质因数即可以合并
                if (map.containsKey(j)) {
                    dp[i + 1] = Math.min(dp[i + 1], map.get(j) + 1);
                }
                //更新每个质因数最后出现之前的最小切割数
                if (dp[i] < map.getOrDefault(j, max)) {
                    map.put(j, dp[i]);
                }
            }

        }
        return dp[n];
    }

    //可以利用递归的思想找出从某个位置进去的最少切割次数
    public static int splitArray(int[] nums) {
        int count = 0;
        dfs(nums, 0, count);
        return min;
    }

    private static void dfs(int[] nums, int index, int count) {
        //找到最后一个数字，其本身就是一个数，所以不用再切割
        if (index == nums.length - 1) {
            min = Math.min(min, count + 1);
            return;
        }
        if (index == nums.length) {
            min = Math.min(min, count);
            return;
        }

        boolean flag = false;
        for (int i = index + 1; i < nums.length; i++) {
            //如果找到一个数和当前进入的索引的数的最大公约数大于1，那么就进入下一个数继续找看后面部分是否符合条件
            //然后再退回来继续找，取最小值
            if (gxy(nums[index], nums[i]) > 1) {
                flag = true;
                dfs(nums, i + 1, count + 1);
            }
        }
        //如果一个合适的数都没有找到，说明当前数无法切割，从当前数下个位置进去找
        if (!flag) {
            dfs(nums, index + 1, count + 1);
        }
    }
    public static int gxy ( int x, int y){
        return y == 0 ? x : gxy(y, x % y);
    }
}
